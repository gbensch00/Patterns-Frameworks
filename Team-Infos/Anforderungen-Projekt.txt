
Welches Spiel?
-> R-Type (Space) Horizontal

----------------------------------
|                            |-|  |
|   |   .   .   .                 |
|                       |-|       |
|                                 |
|       |   .  .   .       |-|    |
|                                 |
----------------------------------

Genaue Spielbeschreibung (Punktzahl, Tod, Zeit)?
->

Welche Architektur?
-> MVC

Welche Packages?
->

Welche Klassen?
->

Welches Pattern (Laut Tony: Wenn MVC, dann wäre Observer Pattern zum Teil schon dabei bzw. geht es in die Richtung)?
->
// Gideon Start
Observer Pattern eignet sich für ein R-Type Spiel sowieso gut: In dem Observer Pattern gibt es ein Subjekt an das ein oder mehrere 'Observer' gekoppelt sind,
über die das Subjekt selbst gar nichts wissen muss, außer dass sie ein gewisses Interface implementieren. Ein Beispiel: In unserem R-Type Spiel ist der 
player character das Subjekt. Dieses Subjekt nimmt Schaden von einem Gegner, wodurch sich der health stat verringert. 
Das Subjekt benachrichtigt den dazugehörigen Observer, also die UI Komponente 'Health Bar', wie viel Health noch übrig bleibt und die Health Bar wird 
geupdated. Dasselbe könnte man z.B. mit Geschwindigkeits oder Schadenspowerups machen.

Zu MVC:
MVC als Struktur hatte ich ja in dem ersten Prototypen schon drin, hier einfach mal die Vorteile bzw. der Sinn dahinter: 
- Trennung der Verantwortlichkeiten, indem die Logik in drei separate Komponenten getrennt wird, wodurch die Anwendung einfacher zu verstehen und zu 
  warten ist. Das macht es auch einfacher für mehrere Entwickler an verschiedenen Komponenten zu arbeiten ohne sich gegenseitig zu behindern.
- MVC ist sehr skalierbar, weil man Komponenten hinzufügen und entfernen kann, ohne die anderen zu beeinträchtigen.
- Beispiel zu konkreter Implementierung: Der GameController nimmt alle User-Inputs der Tastatur entgegen, wenn Inputs den WASD/Leertaste oder bei 2 Spielern auch den Pfeiltasten/Enter
  entsprechen, werden die Funktionen Player.setVelocity() oder shoot() aufgerufen, die dann in den jeweiligen Model- oder Viewklassen veränderungen im Spiel wie hier zum Beispiel die 
  Spielerbewegung bzw. die Schüsse erzeugen.
// Gideon End

Welchen Server (XAMP, Netty, Jetty etc.) und wie Verbindung zum Datenaustausch (JSON, XML etc.)?
-> Zur einfacheren Bereitstellung eines Webservers und einer Datenbank wurde auf das Programm XAMP zurückgeriffen. Auf XAMP wurde über phpmyadmin eine Datenbank erstellt, die den klangvollen Namen TestDB erhalten hat. In dieser existieren zwei Tabellen zur Datenspeicherung. Zum einen die Tabelle PLAYER welche Informationen über Nutzernamen, Passwörter und Highscores enthält. Zum anderen die Tabelle UserSettings in der Informationen wie Avatar, FontSize, FontType, Resolution und BackgroundColor gespeichert sind. Diese Tabelle dient dazu, um User Custumizations durchführen zu können, um so z.B. das Interface farblich anzupassen oder Attribute wie Auflösung oder Schriftgröße zu ändern.

Zum Anmelden wird beim Starten des Spieles nach den Login-Informationen verlangt, diese werden in den Feldern Username und Password eingetragen. Mit einem Klick auf Login werden diese Daten in eine XML-Datei umgewandelt und an den Server geschickt. Wenn die Übertragung erfolgreich war, wird die Benutzeroberfläche aktualisiert, um eine neue Szene (die "Lobby") angezeigt und die alte Szene (das Anmeldefenster) wird geschlossen. Sollte die Anmeldung nicht erfolgreich sein und false durch den Server gemeldet werden, erscheint ein Alert, in dem dem Nutzer mitgeteilt wird, dass der Nutzer nicht existiert oder das verwendete Passwort falsch ist.

Welches UI-Framework?
-> JavaFX
 
Zusammenarbeit?
-> Git 

Einspielung Code?
-> im Branch einspielen
-> Gemeinsam (Mittwochs)
-----------------------------------------------------------------------

Tätigkeiten ausstehend

- Anfertigung Mockups 
- Besorgung Spielfiguren (Sprite?) und Hintergründe
- Umsetzung in Scenebuilder (mit Controller-Klassen)
- Klassenhierarchie erstellen (Klassendiagramm)
- Spiel
    
    -> Spiellogik: Spieler, Gegner, Kollisionserkennung, ein Schuss oder mehrere, Punkteberechnung usw. 
    -> Game: Verwaltet den Spielzustand und die Aktualisierung des Spielstands
    -> Spieler: Spieler (Namen, ID und Punktestand, Bild), Gegner
    -> Controller-Klassen
    -> Anzeige Punktestand
    -> Login und Registrierung (XML, JSON)
    -> Netzwerk: Kommunikation zwischen den Spielern über das Netzwerk (JSON, XML)
    -> Datenbank: Speicherung und den Zugriff auf die Spielerdaten (JDBC-Framework und SQLite?)
    -> Database: Verwaltet den Zugriff auf die Datenbank.

- Erstellung von UML-Komponenten- und Paketdiagrammen
- Wenn noch Zeit: Chat-Funktion, Skins für Player, Sounds für Schießen














Funktionale Anforderungen
-> Grundsätzlich soll ein einfaches Multiplayer-Spiel für mind. 2 Spieler realisiert werden.
-> Als Projektidee wird die Umsetzung oder Abwandlung eines bekannten Arcade-Klassikers vorgeschlagen, 
z.B. Tetris, Tank, Snake, Pac-Man, Dig Dug oder Blobby Volley. Es kann auch ein Brettspiel oder ein Quizspiel 
umgesetzt werden, wobei das GUI geeignet zu animieren bzw. das Spiel um nebenläufige Ereignisse zu erweitern ist. 
Die Spielregeln des Spiels können gerne individuell angepasst werden. Es gibt viel Freiraum für kreative Ideen; die 
finale Spielidee ist mit dem Modulbetreuer abzustimmen.
-> Ein Spieler kann sich registrieren, einloggen und ausloggen.
-> Für jeden Spieler wird eine Historie seiner gespielten Spiele erfasst und mittels einfacher Auswertungen dargestellt 
-> Server-Komponente (Programmiersprache Java): Die registrierten Spieler und ihre Spielhistorie werden zentral in einer 
(relationalen) Datenbank gespeichert. Es wird ein API für den Datenaustausch mit den Clients angeboten, über das Daten im 
JSON- oder XML-Format ausgetauscht werden.
-> Client-Komponente (JavaFX oder mobil)
Der Client bietet ein grafisches UI und setzt die obigen funktionalen Anforderungen um. Für den Client ist JavaFX zu nutzen, 
alternativ das Android Java Framework.

Anforderungen aus Projekt (min. Zwei)
Vorzugsweise bringt Ihr eigene Ideen für interessante Features oder Aspekte ein, die wir dann frühzeitig abstimmen. Die folgenden Liste enthält Beispiele für Zusatzanforderungen:

-> Das GUI kann vom Spieler in nicht-trivialem Umfang individualisiert werden (z.B. über Skins). Die Einstellungen werden auf dem Server gespeichert.
-> Es wird ein Framework für das objekt-relationale Mapping eingesetzt.
-> Es werden auch Bilder zwischen Client und Server ausgetauscht (z.B. die Profilbilder der Anwender)
-> Es wird eine fortgeschrittene Spielarchitektur umgesetzt, z.B. ECS.
-> Die Authentifizierung erfolgt über JSON Web Tokens (JWT).
-> Es gibt eine sinnvolle Verwendung von Threading außerhalb des GUI-Frameworks.

Sonstige Anforderungen
-> Die Projekte müssen eine README enthalten, die mindestens beschreibt, wie die Anwendung gebaut werden kann und welche 
Voraussetzungen gelten (Java/Maven/Gradle Versionen etc.). Auch Informationen darüber, wie Clients und Server gestartet 
werden, so dass sie miteinander funktionieren sind ggf. zu dokumentieren.
